# 👤 최수연 | Datarize Frontend 과제 전형

### ⏱️ **2025.12.16 15:00 – 2025.12.17 15:00**

> 과제 요구사항은 [`REQUIREMENTS.md`](./REQUIREMENTS.md) 파일에 정리되어 있습니다.

## 📌 프로젝트 실행 방법

### 프로젝트 실행

```cmd
cd apps
yarn install
yarn start-server
yarn start-client
```

### 테스트 실행

```cmd
cd apps/frontend
yarn test
yarn test:watch
```

## 📌 기술 스택 및 라이브러리 선택 이유

### 1️⃣ Ant Design

본 프로젝트는 Figma 기반의 UI 시안이나 별도의 디자인 시스템이 제공되지 않은 상태에서 진행되었습니다.

이에 따라, 기본적인 디자인 체계와 컴포넌트를 제공하는 Ant Design을 활용하여 UI 구현에 소요되는 시간을 줄이고, 기능 구현에 보다 집중할 수 있도록 했습니다.

### 2️⃣ Emotion

Ant Design을 사용하면서 스타일을 인라인으로 제어해야 하는 경우가 많아,
컴포넌트 구조가 복잡해지고 가독성이 떨어지는 문제가 발생했습니다.

이를 해결하기 위해 Emotion을 도입하여,
구조 파악이 어려운 경우에 한해 스타일을 컴포넌트 단위로 분리하고
스타일과 로직의 역할을 보다 명확하게 구분할 수 있도록 구성했습니다.

### 3️⃣ Tanstack Query

서버 상태를 효율적으로 관리하기 위해 TanStack Query를 사용했습니다.

대시보드 특성상 데이터가 실시간으로 자주 변경되지 않으며,
이번 과제의 데이터 역시 작년 데이터를 기반으로 하고 있어
불필요한 재요청보다는 캐싱을 통한 성능 최적화가 더 적합하다고 판단했습니다.

### 4️⃣ Recharts

가격대별 구매 빈도를 시각적으로 표현하기 위해 Recharts를 사용하여
Bar Chart를 구현했습니다.

이 과정에서 런타임에 Recharts 내부 동작에 필요한 react-is 라이브러리를 의존성으로 함께 설치하여 사용했습니다.

### 5️⃣ Vitest, React Testing Library

테스트 환경은 Vite 기반 프로젝트와의 궁합을 고려하여 Vitest를 선택했습니다. 또한, React 컴포넌트 및 훅 테스트를 위해 React Testing Library를 사용했습니다.

이와 함께 DOM 환경을 제공하기 위해 jsdom과 DOM 기반 쿼리를 지원하는 Testing Library DOM을 함께 구성했습니다.

## 📌 프로젝트 구조

본 프로젝트는 Feature-Sliced Design(FSD) 아키텍처를 기반으로 구성했습니다.
각 레이어의 역할을 명확히 분리하여 책임 경계를 분명히 하고,
기능 단위로 확장 및 유지보수가 가능하도록 설계했습니다.

```
datarize-fe-assignments/
├── apps/
│   └── frontend/                         # Frontend (FSD 기반 구조)
│       ├── src/
│       │   ├── app/                      # 🎯 App Layer
│       │   │   ├── App.tsx
│       │   │   └── providers/            # 전역 Provider 설정
│       │   │       ├── antd/              # Ant Design 설정
│       │   │       ├── tanstack-query/    # TanStack Query 설정
│       │   │       └── index.tsx
│       │   │
│       │   ├── pages/                    # 📄 Pages Layer
│       │   │   └── dashboard/
│       │   │       ├── DashboardLayout/  # 대시보드 레이아웃
│       │   │       ├── DashboardPage/    # 대시보드 페이지
│       │   │       └── index.tsx
│       │   │
│       │   ├── features/                 # 🎨 Features Layer
│       │   │   ├── customer-detail/      # 고객 상세 정보 기능
│       │   │   │   ├── index.tsx
│       │   │   │   └── ui/
│       │   │   ├── customer-list/        # 고객 목록 기능
│       │   │   │   ├── index.tsx
│       │   │   │   └── ui/
│       │   │   └── purchase-frequency/   # 구매 빈도 차트 기능
│       │   │       ├── index.tsx
│       │   │       └── ui/
│       │   │
│       │   ├── entities/                 # 🏗️ Entities Layer
│       │   │   ├── customer/             # Customer 엔티티
│       │   │   │   ├── api/               # API 요청 정의
│       │   │   │   ├── model/             # 도메인 모델 및 공개 타입
│       │   │   │   │                       # (API DTO와 분리하여 외부에서 API 타입 직접 참조 방지)
│       │   │   │   └── query/             # TanStack Query 관련 로직
│       │   │   │
│       │   │   └── purchase/             # Purchase 엔티티
│       │   │       ├── api/
│       │   │       ├── model/
│       │   │       └── query/
│       │   │
│       │   ├── shared/                   # 🔧 Shared Layer
│       │   │   ├── apis/                 # 공통 API 유틸리티
│       │   │   ├── assets/               # 공통 에셋
│       │   │   ├── hooks/                # 공통 훅
│       │   │   ├── lib/                  # 공통 유틸리티 함수
│       │   │   └── ui/                   # 공통 UI 컴포넌트
│       │   │
│       │   ├── main.tsx                  # 진입점
│       │   └── index.css                 # 전역 스타일
```

## 📌 테스트 전략 및 구현 내용

본 프로젝트에서 필요한 부분에 유닛 테스트를 진행했습니다.

`formatPriceRange` 유틸리티 함수와 `useDebounce` 커스텀 훅에 대한 테스트를 작성하여 각 기능이 의도한 대로 동작하는지 검증했습니다.

## 📌 로딩 처리 방식

API 요청에 대한 로딩 처리는 쿼리 타입에 따라 다르게 구현했습니다.

### 1️⃣ `useSuspenseQuery`를 사용한 경우

`useSuspenseQuery`를 사용한 경우(구매 빈도 차트), React의 `Suspense`로 감싸서 로딩 상태를 처리했습니다. 이는 Suspense의 선언적 로딩 처리 방식을 활용하기 위함입니다.

### 2️⃣ `useQuery`를 사용한 경우

`useQuery`를 사용한 경우(고객 목록, 고객 구매 내역)에는 `useSuspenseQuery`를 사용하지 않았습니다. 특히 고객 목록의 경우 정렬 기능이 있는 테이블로, 사용자가 정렬을 변경할 때마다 데이터가 재요청되는데, 이때 Suspense를 사용하면 전체 컴포넌트가 언마운트되고 다시 마운트되는 과정을 거치게 되어 테이블의 정렬 상태나 사용자 경험에 부정적인 영향을 줄 수 있다고 판단했습니다.

따라서 `useQuery`를 사용한 경우에는 `isLoading`과 `isFetching`을 활용하여 초기 데이터 로딩과 추가 데이터 재요청에 대한 로딩 처리를 구분했습니다. 로딩 상태는 Ant Design의 `Spin` 컴포넌트를 사용하여 표시했습니다.

## 📌 에러 처리 방식

### 1️⃣ 기본 Fetch 에러 처리

API 요청은 공통 `httpGet` 함수를 통해 처리되며, 응답 상태 코드가 `ok`가 아닌 경우 커스텀 `HttpError`를 throw합니다. `HttpError`는 HTTP 상태 코드를 포함하여 이후 에러 처리에서 상태 코드를 확인할 수 있도록 했습니다. 다만, 현재 코드에서는 `HttpError`를 throw한 이후 별도의 추가 핸들링 로직은 없으며, Tanstack Query의 기본 에러 처리 흐름을 따르고 있습니다.

### 2️⃣ Tanstack Query 내부 에러 처리

Tanstack Query의 `QueryClient` 설정에서 `throwOnError: true`로 설정했습니다. 이는 `queryFn`에서 throw된 에러가 Tanstack Query에 의해 자동으로 처리되도록 합니다. Tanstack Query는 에러가 발생하면 해당 쿼리의 상태를 `error`로 변경하고, `useQuery`나 `useSuspenseQuery`를 사용하는 컴포넌트에서 에러를 전파합니다. `useSuspenseQuery`의 경우 에러가 발생하면 가장 가까운 `ErrorBoundary`로 에러가 전파됩니다.

### 3️⃣ 특수 케이스 처리

고객 목록 검색 쿼리(`useCustomersQuery`)의 경우, 검색 결과가 없을 때 서버에서 404 상태 코드를 반환합니다. 이 경우를 에러로 처리하기보다는 빈 배열로 반환하도록 처리했습니다. `queryFn` 내부에서 `HttpError`를 catch하여 상태 코드가 404인 경우 빈 배열을 반환하고, 그 외의 에러는 다시 throw하여 일반적인 에러 처리 흐름을 따르도록 했습니다.

### 4️⃣ ErrorBoundary를 통한 에러 UI 처리

에러 처리를 위해 `ErrorBoundary`를 구현했습니다. 에러 발생 시 전체 쿼리를 다시 리패치하는 것보다는, `queryKey`를 지정하여 해당 쿼리만 리셋하고 리패치하는 것이 더 효율적이라고 판단했습니다. 이렇게 하면 에러가 발생한 특정 기능만 재시도할 수 있어 다른 기능에 영향을 주지 않고, 불필요한 네트워크 요청도 줄일 수 있습니다.

## 📌 고민 및 아쉬운 점

### 1️⃣ 스타일 관리의 어려움

Ant Design을 사용하면서 스타일 격리가 어려웠습니다. 디자인 시스템이 없어 기본 디자인이 잘 구현된 프레임워크를 선택했지만, 스타일별 우선순위가 달라 어디까지 styled Component로 분리할지, 인라인 객체로 분리할지 판단이 애매했습니다. 또한 Ant Design의 `styles` 속성과 일반 `style` 속성을 혼용하게 되어 통일성이 떨어졌습니다.

현재 적용한 기준은 다음과 같습니다.

- 전체 컴포넌트 구조 파악이 중요한 `DashboardPage` 같은 곳은 Emotion의 styled component로 스타일을 완전히 격리
- 그 외에는 CSS 인라인 객체로만 분리 (동적 스타일링이 필요 없고 재사용하지도 않으므로 별도 파일 생성 불필요)
- 길지 않은 style 속성은 인라인에 유지 (격리 코드가 더 길어질 수 있음)

### 2️⃣ Ant Design RangePicker의 한계

단일 날짜 선택이 간헐적으로 동작하지 않는 문제가 있습니다. 계속 하다보면 단일 날짜 선택(from, to)도 잘 됩니다. 이 문제는 Ant Design의 `RangePicker` 컴포넌트의 문제라서 다른 컴포넌트를 활용해 구현할 수도 있었지만, 해당 컴포넌트가 `날짜 범위를 나타내는 UX적 의미가 강해` 그대로 사용하기로 결정했습니다.

### 3️⃣ staleTime 설정에 대한 고민

각 쿼리의 `staleTime`은 다음과 같이 설정했습니다.

- **고객 목록(`useCustomersQuery`)**: 30분
- **고객 구매 내역(`useCustomerPurchasesQuery`)**: 30분
- **구매 빈도(`usePurchaseFrequencySuspenseQuery`)**: 30분

세 쿼리는 모두 구매 내역이라는 동일한 도메인 데이터를 기반으로 하고 있어,
대시보드 내 데이터 일관성을 유지하기 위해 `staleTime`을 30분으로 통일했습니다.

구매 내역 데이터는 실시간으로 자주 변경되는 성격이 아니며,
사용자가 즉각적인 최신 상태를 확인해야 할 필요도 크지 않다고 판단했습니다.
이에 따라 불필요한 재요청을 줄이고 캐싱 이점을 살릴 수 있도록 30분을 기준으로 설정했습니다.

하지만, 현재 제공되는 데이터가 2024년 기준의 정적 데이터라는 점을 고려한 선택이기 때문에,
실시간 데이터나 빈번한 변경이 발생하는 환경이라면 `staleTime` 설정 역시 충분히 조정될 수 있다고 생각합니다.

### 4️⃣ 대용량 데이터 처리에 대한 고민

현재는 데이터 규모가 작아 문제가 없지만, 추후 고객 데이터가 대량으로 증가할 경우를 가정하여 고민해봤습니다. 이 경우 TanStack Virtual을 활용한 가상화 무한 스크롤을 적용하는 방안을 검토했지만, 검색 시 동일한 이름을 가진 고객이 많을 경우 몇 번째 고객인지 파악하기 어렵다는 문제가 있어, 검색 기능에는 무한 스크롤보다 페이지네이션이 더 적합할 것 같다고 판단했습니다. 다만 현재는 구현하지 않았으며, 실제로 데이터가 증가할 때 다시 검토가 필요할 것 같습니다.

### 5️⃣ URL 쿼리 파라미터를 통한 상태 관리 고민

현재 차트 날짜 범위, 고객 ID, 정렬 방식 등을 내부 상태로 관리하고 있어, 새로고침 시 초기 상태로 돌아가는 문제가 있습니다. 예를 들어, 2015년 데이터를 계속 확인하다가 실수로 새로고침하면 매번 다시 2015년까지 날짜를 조정해야 하는 불편함이 있습니다. 고객 상세 내역도 마찬가지로, 특정 고객을 선택한 상태에서 새로고침하면 다시 해당 고객을 찾아가야 합니다. 이를 해결하기 위해 URL 쿼리 파라미터로 상태를 저장하는 방안을 고려하긴 했지만, 현재는 시간 관계상 구현하지 않았습니다.

### 6️⃣ 이미지 캐싱 문제

고객 상세 구매 내역 API 호출 시 이미지가 매번 새로 불러와지는 문제가 있습니다. 서버 응답 헤더에 `max-age=0`으로 설정되어 있어 이미지 캐싱이 제대로 동작하지 않고 있습니다. 때문에 동일한 이미지를 반복적으로 다운로드하게 되어 성능 최적화 측면에서 개선이 필요하다고 생각합니다.

### 7️⃣ API 응답 설계에 대한 궁금증

검색어가 없을 때 서버에서 404 상태 코드를 반환하는데, 클라이언트 입장에서는 빈 배열을 반환하는 것이 더 관리하기 편할 것 같습니다. 현재는 `queryFn` 내부에서 404를 catch하여 빈 배열로 변환하는 방식으로 처리했지만, 서버 측에서 빈 배열을 반환하는 것이 더 적절한 API 설계일 수 있다고 생각합니다.
